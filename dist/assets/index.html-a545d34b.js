import{_ as a,K as t,L as n,a5 as l,M as e,N as r,W as o,F as s}from"./framework-edebdfe1.js";const c={},d=e("h1",{id:"漏洞挖掘",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#漏洞挖掘","aria-hidden":"true"},"#"),r(" 漏洞挖掘")],-1),h=e("div",{class:"hint-container warning"},[e("p",{class:"hint-container-title"},"DeeLMind 提示"),e("p",null,"漏洞挖掘，主要指二进制漏洞挖掘，本质就是逆向分析，WEB漏洞不在此，因此漏洞挖掘需要很强的二进制基础。")],-1),_=o('<h2 id="漏洞类型" tabindex="-1"><a class="header-anchor" href="#漏洞类型" aria-hidden="true">#</a> 漏洞类型</h2><ul><li>栈溢出漏洞（Stack-Overflow）</li><li>堆溢出漏洞（Heap-Overflow）</li><li>释放后重引用漏洞（Use-After-Free）</li><li>双重释放漏洞（Double-Free）</li><li>越界访问漏洞（Out-of-Bounds)</li><li>字符串格式化漏洞（Format-String）</li></ul><h2 id="漏洞挖掘工具" tabindex="-1"><a class="header-anchor" href="#漏洞挖掘工具" aria-hidden="true">#</a> 漏洞挖掘工具</h2><ul><li>FUZZ工具</li><li>AFL++</li><li>WinAFL</li><li>调试工具</li></ul><h2 id="编译保护" tabindex="-1"><a class="header-anchor" href="#编译保护" aria-hidden="true">#</a> 编译保护</h2><ul><li>GS 缓存区检查</li><li>PIE（ASLR）</li><li>CANNARY(栈保护)</li><li>FORTIFY</li><li>NX（DEP）</li><li>RELRO</li><li>PIE</li></ul>',6);function u(f,x){const i=s("DocsAD");return t(),n("div",null,[d,h,l(i),l(i),l(i),_])}const p=a(c,[["render",u],["__file","index.html.vue"]]);export{p as default};
